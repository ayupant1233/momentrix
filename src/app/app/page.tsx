import { redirect } from "next/navigation";
import { getServerSession } from "next-auth";
import { Prisma } from "@prisma/client";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import Link from "next/link";
import DashboardNav from "@/components/dashboard-nav";
import { format } from "date-fns";
import clsx from "clsx";

const savedPhotographerSelect = Prisma.validator<Prisma.PhotographerProfileSelect>()({
  id: true,
  userId: true,
  headline: true,
  city: true,
  verificationStatus: true,
  hourlyRate: true,
  fullDayRate: true,
  travelRadiusKm: true,
  tags: true,
  services: true,
  user: {
    select: {
      name: true,
      email: true,
      phone: true,
    },
  },
  reviews: {
    take: 1,
    orderBy: { createdAt: "desc" },
    select: { rating: true },
  },
});

type SavedPhotographerSummary = Prisma.PhotographerProfileGetPayload<{ select: typeof savedPhotographerSelect }>;

async function getDashboardData(userId: string, role: string) {
  if (role === "PHOTOGRAPHER") {
    const profile = await prisma.photographerProfile.findUnique({
      where: { userId },
      include: {
        portfolioItems: {
          take: 3,
          orderBy: { createdAt: "desc" },
        },
        posts: {
          take: 3,
          orderBy: { createdAt: "desc" },
        },
        reviews: {
          take: 3,
          orderBy: { createdAt: "desc" },
          include: {
            booking: true,
          },
        },
        availability: {
          take: 3,
          orderBy: { startTime: "asc" },
        },
      },
    });

    const pendingBookings = await prisma.booking.count({
      where: { photographerId: userId, status: "REQUESTED" },
    });

    const bookingRequests = await bookingRequestDelegate().findMany({
      where: { status: "SUBMITTED" },
      orderBy: { createdAt: "desc" },
      take: 5,
    });

    const socialAccounts = await socialAccountDelegate().findMany({
      where: { userId },
      select: {
        provider: true,
        followerCount: true,
        verifiedAt: true,
      },
    });

    return { profile, pendingBookings, bookingRequests, socialAccounts };
  }

  if (role === "CLIENT") {
    const profile = await prisma.clientProfile.findUnique({
      where: { userId },
      include: {
        user: true,
      },
    });

    const activeRequests = await prisma.booking.count({
      where: { clientId: userId, status: { in: ["REQUESTED", "CONFIRMED"] } },
    });

    const followRecords = await photographerFollowDelegate().findMany({
      where: { clientId: userId },
      select: { photographerId: true },
      take: 24,
    });

    const photographerIds = followRecords.map((f) => f.photographerId);

    const savedPhotographers: SavedPhotographerSummary[] =
      photographerIds.length > 0
        ? await prisma.photographerProfile.findMany({
            where: {
              id: { in: photographerIds },
            },
            orderBy: { createdAt: "desc" },
            select: savedPhotographerSelect,
          })
        : [];

    const bookingRequests = await bookingRequestDelegate().findMany({
      where: { clientId: userId },
      orderBy: { createdAt: "desc" },
      take: 6,
    });

    return { profile, activeRequests, savedPhotographers, bookingRequests };
  }

  return {};
}

type DashboardResult = Awaited<ReturnType<typeof getDashboardData>>;

type ClientDashboard = Extract<DashboardResult, { activeRequests: number }>;
type PhotographerDashboard = Extract<DashboardResult, { pendingBookings: number }>;

type AlertMessage = {
  title: string;
  description: string;
  action?: { label: string; href: string };
};

type QuickAction = {
  label: string;
  description: string;
  href: string;
};

type ProgressItem = {
  label: string;
  done: boolean;
  href?: string;
};

function isClientDashboard(data: DashboardResult): data is ClientDashboard {
  return Object.prototype.hasOwnProperty.call(data, "activeRequests");
}

function isPhotographerDashboard(data: DashboardResult): data is PhotographerDashboard {
  return Object.prototype.hasOwnProperty.call(data, "pendingBookings");
}

type BookingRequestDelegate = {
  findMany: (...args: any[]) => Promise<any[]>;
};

function bookingRequestDelegate(): BookingRequestDelegate {
  const delegate = (prisma as unknown as { bookingRequest?: BookingRequestDelegate }).bookingRequest;
  if (!delegate) {
    throw new Error(
      "BookingRequest delegate is unavailable. Ensure Prisma client is generated by running `npx prisma generate`."
    );
  }
  return delegate;
}

type SocialAccountDelegate = {
  findMany: (...args: any[]) => Promise<any[]>;
};

function socialAccountDelegate(): SocialAccountDelegate {
  const delegate = (prisma as unknown as { socialAccount?: SocialAccountDelegate }).socialAccount;
  if (!delegate) {
    throw new Error(
      "SocialAccount delegate is unavailable. Ensure Prisma client is generated by running `npx prisma generate`."
    );
  }
  return delegate;
}

type PhotographerFollowDelegate = {
  findMany: (...args: any[]) => Promise<Array<{ photographerId: string }>>;
};

function photographerFollowDelegate(): PhotographerFollowDelegate {
  const delegate = (prisma as unknown as { photographerFollow?: PhotographerFollowDelegate }).photographerFollow;
  if (!delegate) {
    throw new Error(
      "PhotographerFollow delegate is unavailable. Ensure Prisma client is generated by running `npx prisma generate`."
    );
  }
  return delegate;
}

export default async function AppHome() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    redirect("/login?callbackUrl=/app");
  }

  // Redirect to role-specific dashboard
  if (session.user.role === "CLIENT") {
    redirect("/client/dashboard");
  } else if (session.user.role === "PHOTOGRAPHER") {
    redirect("/photographer/dashboard");
  }

  // Fallback redirect if role is not recognized
  redirect("/login");
}
